\documentclass[10pt,twocolumn,letterpaper]{article}

\usepackage{cvpr}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb, comment, microtype, kotex}

\makeatletter
\@namedef{ver@everyshi.sty}{}
\makeatother
\usepackage{booktabs,tikz,xcolor,float}

\usetikzlibrary{arrows,snakes,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\tikzset{>=stealth',every on chain/.append style={join},
         every join/.style={->}}


\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}

\cvprfinalcopy

\begin{document}

\title{Neural Sign Language Translation based on Human Keypoint Estimation}

\author{Sang-Ki Ko \and Chang Jo Kim \and Hyedong Jung \and Choongsang Cho\\
Korea Electronics Technology Institute\\
22 Dawangpangyo-ro 712 beon-gil, Seongnam-Si, Gyeonggi-do 13488, South Korea\\
{\tt\small \{narame7,wowchangjo,hudson.keti,ideafisher.cho\}@gmail.com}
}

\maketitle

\begin{abstract}
We propose a sign language translation system based on human keypoint estimation. It is well-known that many problems in the field of computer vision require a massive amount of dataset to train deep neural network models. The situation is even worse when it comes to the sign language translation problem as it is far more difficult to collect high-quality training data. In this paper, we introduce the KETI sign language dataset which consists of 11,578 videos of high resolution and quality. Considering the fact that each country has a different and unique sign language, the KETI sign language dataset can be the starting line for further research on the Korean sign language translation.

Using the KETI sign language dataset, we develop a neural network model for translating sign videos into natural language sentences by utilizing the human keypoints extracted from a face, hands, and body parts. The obtained human keypoint vector is normalized by the mean and standard deviation of the keypoints and used as input to our translation model based on the sequence-to-sequence architecture. As a result, we show that our approach is robust even when the size of the training data is not sufficient. Our translation model achieves 94.6\% (60.6\%, respectively) translation accuracy on the validation set (test set, respectively) for 105 sentences that can be used in emergency situations. We compare several types of our neural sign translation models based on different attention mechanisms in terms of classical metrics for measuring the translation performance.
\end{abstract}

\section{Introduction}
Sign language recognition or translation is a study that interprets a visual language that has its independent grammar into a spoken language. The visual language combines various information on the hands and facial expression according to this grammar to present the exact meaning~\cite{ForsterSHKZPN12,von2008significance}. The issue is a challenging subject in computer vision and a significant topic for hearing-impaired people.

In recent years, Recurrent Neural Networks (RNNs), Long Short-Term Memory (LSTM) architecture~\cite{HochreiterS97}, and  Gated Recurrent Units (GRUs)~\cite{ChovGBBSB14} in particular, have been primarily employed as essential approaches to model a sequence and solve the sequence to sequence problems such as machine translation and image captioning~\cite{dai2017contrastive,liu2017attention,SutskeverVL14,xu2015show}. Convolutional neural networks (CNNs) are powerful models that have archived excellent performance in various visual tasks such as image classification~\cite{husqueeze,huang2017densely}, object detection~\cite{gao2017dynamic,redmon2016you}, semantic segmentation~\cite{long2015fully,zhang2018context}, and action recognition~\cite{donahue2015long,luvizon20182d}.

Sign language with a unique grammar express the linguistic meaning through the shape and movement of hands, moreover, the facial expression that present emotion and specific intentions~\cite{von2008significance}. Understanding sign languages that it requires a high level of spatial and temporal knowledge is difficult with the current level of computer vision techniques based on neural networks~\cite{DongLY15,ForsterSHKZPN12,gattupalli2016evaluation,KishoreSK14,KollerFN15,koller2017re,StarnerP95}.
More importantly, the main difficulty comes from the lack of dataset for training neural networks. Many sign languages represent different words and sentences of spoken languages with gestures sequences comprising continuous pose of hands and facial expressions while `hand (finger) languages' only represent each letter in an alphabet with the shape of a single hand~\cite{CamgozHKNB18}. This implies that there are uncountably many combinations of the cases even to describe a single human intention with the sign language.

Hence, we restrict ourselves to a specific domain which is related to various emergencies. We build the Korean sign language dataset collected from eleven Korean professional signers who are hearing-impaired people. The dataset consists of high-resolution videos that recorded Korean sign languages corresponding to 419 words and 105 sentences related to various emergency situations.
We, then, present our sign language translation system based on human keypoints of hands, pose, and face. Our system is trained and tested with the sign language dataset built by our corpus, and we show a robust performance considering that the scale of dataset is not large enough.

\section{Related Work}
There have been many approaches to recognize `hand languages' that are used to describe letters of the alphabet with a single hand. It is relatively easier than recognizing sign languages as each letter of the alphabet simply corresponds to a unique hand shape. %In~\cite{DongLY15}, the authors have utilized depth cameras (Microsoft's Kinect) to recognize the English alphabet and have shown 92\% recognition accuracy.
In~\cite{DongLY15}, an English alphabet is recognized using a Random Forest (RF) method to classify hand poses expressed by depth images and it shown 92\% recognition accuracy. A pose estimation method of the upper body represented by seven key points was proposed for American Sign Language (ASL) alphabet recognition.~\cite{gattupalli2016evaluation}. We also note that there has been an approach by Kim et al.~\cite{KimK16} to recognize the Korean hand language by analyzing latent features of hand images.

In general, researchers rely on the movements and shapes of both hands to recognize sign languages. Starner et al.~\cite{StarnerP95} have developed a real-time system based on Hidden Markov model (HMM) to recognize sentence-level ASL. They have demonstrated two experimental results: they have used solidly colored gloves to make tracking of hands easier in the first experiment and the second experiment have been conducted without gloves. They have claimed that the word accuracy of glove-based system is 99.2\% but the accuracy drops to 84.7\% if they do not use gloves. It should be noted that those accuracy can be reached because they have exploited the grammar to reviewing the errors of the recognition. The word accuracy without grammar and gloves is 74.5\%.

On the other hand, there have been approach to automatically learning signs from weakly annotated data such as TV broadcasts by using subtitles provided simultaneously with the signs~\cite{BuehlerZE09,CooperB09,PfisterCZ13}. Following this direction, Forster et al. released the RWTH-PHOENIX-Weather 2012~\cite{ForsterSHKZPN12} and its extended version RWTH-PHOENIX-Weather 2014~\cite{ForsterSKBN14} that consist of weather forecasts recorded from German public TV and manually annotated using glosses and natural language sentences where time boundaries have been marked on the gloss and the sentence level. Based on the RWTH-PHOENIX-Weather corpus, Koller et al.~\cite{KollerFN15} have presented a statistical approach performing large vocabulary continuous sign language recognition across different signers. They have developed a continuous sign language recognition system that utilizes multiple information streams including the hand shape, orientation and position, the upper body pose, and face expression such as mouthing, eye brows and eye gaze.

Until recently, there have been many attempts to recognize and translate sign language using deep learning (DL). Oberweger et al.~\cite{OberwegerWL15} have introduced and evaluated several architectures for CNNs to predict the 3D joint locations of a hand given a depth map. Kishore et al.~\cite{KishoreSK14} have developed a sign language recognition system that is robust in different video backgrounds by extracting signers using boundary and prior shape information. Then, the feature vector is constructed from the segmented signer and used as input to artificial neural network. An end-to-end sequence modelling using CNN-BLSTM architecture usually used for gesture recognition was proposed for large vocabulary sign language recognition with RWTH-PHOENIC-Weather 2014~\cite{koller2017re}.

At the same time, one of the most interesting breakthroughs in neural machine translation or even in the entire DL was introduced under the name of `sequence-to-sequence (seq2seq)'~\cite{SutskeverVL14}. The seq2seq model relies on a common framework called an encoder-decoder model with RNN cells such as LSTMs or GRUs. The seq2seq model proved its effectiveness in many sequence generation tasks by achieving almost the human-level performance~\cite{SutskeverVL14}. Despite its effectiveness, the seq2seq model still has some drawbacks such as the input sequences of varying lengths being represented in fixed-size vectors and the vanishing gradient due to the long-term dependency between distant parts.

Camgoz et al.~\cite{CamgozHKNB18} formalized a sign language translation based on the pre-existing framework of Neural Machine Translation (NMT) with word and spatial embeddings for target sequences and sign videos, respectively.
The extracted non-linear frame from a sign video is converted into the spatial representation through $2D$ CNN, and then it is tokenized.
The sequence-to-sequence (seq2seq) based deep learning methods learns how to translate the spatio-temproal representation of signs into the spoken or written language.
Recently, researchers developed a simple sign language recognition system based on bidirectional GRUs which just classifies a given sign language video into one of the classes that are predetermined~\cite{KoSJ18}


\begin{figure*}
\centering
\begin{tikzpicture}[
  hid/.style 2 args={
    rectangle split,
    rectangle split horizontal,
    draw=#2,
    rectangle split parts=#1,
    fill=#2!20,
    outer sep=0.5mm,
    inner sep=1.5mm,
    rounded corners}]

    \node[inner sep=0.5mm] (i1) at (2.5*1, -6.25) {\includegraphics[height=0.6in, width=0.9in]{frame_86.png}};
    \node[inner sep=0.5mm] (i2) at (2.5*2, -6.25) {\includegraphics[height=0.6in, width=0.9in]{frame_94.png}};
    \node[inner sep=0.5mm] (i3) at (2.5*3, -6.25) {\includegraphics[height=0.6in, width=0.9in]{frame_128.png}};

    \node[inner sep=0.5mm] (i21) at (2.5*1, -3.65) {\includegraphics[height=0.6in, width=0.9in]{frame_86_keypoint.png}};
    \node[inner sep=0.5mm] (i22) at (2.5*2, -3.65) {\includegraphics[height=0.6in, width=0.9in]{frame_94_keypoint.png}};
    \node[inner sep=0.5mm] (i23) at (2.5*3, -3.65) {\includegraphics[height=0.6in, width=0.9in]{frame_128_keypoint.png}};
  \foreach \t[count=\step from 4] in {I, am,burned,{{$<$eos$>$}}} {
    \node[align=center] (o\step) at (2.5*\step, -1.4) {\t};
  }
  \foreach \step in {1,...,3} {
    \node[hid={1}{red}] (h\step) at (2.5*\step, -0.7) {Enc. GRU};
    \node[hid={1}{red}] (e\step) at (2.5*\step, -1.6) {Enc. GRU};
    \draw[->] (i\step.north) -> (i2\step.south);
    \draw[->] (i2\step.north) -> (e\step.south);
    \draw[->] (e\step.north) -> (h\step.south);
  }


    \node (i4) at (2.5*4, -5.9) {$<$sos$>$};
    \node (output5) at (2.5*5, -5.9) {I};
    \node (output6) at (2.5*6, -5.9) {am};
    \node (output7) at (2.5*7, -5.9) {burned};

  \foreach \step in {4,...,7} {
    \node[hid={1}{yellow}] (s\step) at (2.5*\step, -2.25) {Softmax};
    \node[hid={1}{blue}] (h\step) at (2.5*\step, -3.1) {Dec. GRU};
    \node[hid={1}{blue}] (e\step) at (2.5*\step, -4.0) {Dec. GRU};
    \node[hid={1}{orange}] (embedding\step) at (2.5*\step, -5.0) {Embedding};
    \draw[->] (e\step.north) -> (h\step.south);
    \draw[->] (h\step.north) -> (s\step.south);
    \draw[->] (s\step.north) -> (o\step.south);
    \draw[->] (embedding\step.north) -> (e\step.south);
  }
  \draw[->] (output5.north) -> (embedding5.south);
  \draw[->] (output6.north) -> (embedding6.south);
  \draw[->] (output7.north) -> (embedding7.south);

\node[draw=green, fill=green!30, rectangle, minimum width=7cm, rounded corners] at (5, -2.4) {Feature Normalization};
\node[draw=green, fill=green!30, rectangle, minimum width=7cm, rounded corners] at (5, -4.95) {Human Keypoint Estimation};

  \draw[->] (i4.north) -> (embedding4.south);
  \foreach \step in {1,...,2} {
    \pgfmathtruncatemacro{\next}{add(\step,1)}
    \draw[->] (h\step.east) -> (h\next.west);
  }
  \foreach \step in {4,...,6} {
    \pgfmathtruncatemacro{\next}{add(\step,1)}
    \draw[->] (h\step.east) -> (h\next.west);
  }
  \path (h3.east) edge[->,out=-50,in=-240] (h4.west);
  \foreach \step in {4,...,6} {
    \pgfmathtruncatemacro{\next}{add(\step,1)}
    \path (o\step.north) edge[->,out=45,in=225] (output\next.south);
  }
\end{tikzpicture}
\caption{An overall architecture of our approach that translates a sign language video into a natural language sentence using sequence to sequence model based on GRU cells.}
\end{figure*}


\section{KETI Sign Language Dataset}

The KETI dataset is constructed to understand the Korean sign language of hearing-impaired people in various emergencies because they are challenging to cope with the situations and sometimes are in severe conditions.
In that cases, even when they are aware of that situations, it is very hard to report the situations and receive help from government agencies due to the communication problem.
Therefore, we have carefully examined the relatively general conversation of emergency cases and chosen useful 105 sentences and 419 words used in such situations.

The KETI sign language dataset consists of 11,578 full high definition (HD) videos, that are recorded at 30 frames per second and from two camera angles; front and side. The dataset is recorded by the designed corpus and contains sentences and words performed by eleven different hearing-impaired signers to eliminate the expression error by signers who are non-disabled people. Moreover, the meanings of the sentences and words are delivered to hearing-impaired signers through the expert's sign languages in order to induce the correct expression.
Each signer records a total of 1,048 videos for the dataset. For the training and validation sets, we have chosen ten signers from eleven signers and chosen nine sign videos for each sign for the training set. The remaining sign videos are assigned to the validation set. The Test Set consists of a single signer whose sign video does not exist in the training set or the validation set. Several statistics of the dataset are given in Table~\ref{tab:dataset} and an example frame from the dataset is presented in~Figure~\ref{fig:example_frame}.

In particular, we have annotated each of the 105 signs that correspond to the useful sentences in emergencies mentioned above with five different natural language sentences in Korean.
Moreover, we have annotated all sign videos with the corresponding sequences of {\em glosses}~\cite{Liddell03}, where a gloss is a unique word that corresponds to a unit sign and used to transcribe sign language. For instance, a sign implying `I am burned.' can be annotated with the following sequence of glosses: (`FIRE', `SCAR'). Similarly, a sentence `A house is on fire.' is annotated by (`HOUSE', `FIRE').
Apparently, glosses are more appropriate to annotate a sign because it is possible to be expressed in various natural sentences or words with the same meaning. For this reason, we have annotated all signs with the glosses with the help of Korean sign language experts.

For the communication with hearing-impaired people in the situations, the KETI dataset is used to develop an artificial intelligence-based sign language recognizer or translator. All videos are recorded in a blue screen studio to minimize any undesired influence and learn how to recognize or translate the signs with insufficient data.










\begin{table}[htb]\label{tab:dataset}
\centering
\begin{tabular}{@{  }p{3.1cm}ccc@{  }}
\toprule
Metric  & Training & Dev & Test\\ \midrule
\# of sign videos  & 9,432 & 1,048 & 1,048  \\
Duration [hours]  & 20.05 & 2.24 & 1.82\\
\# of frames  & 2,165,682 & 241,432 & 153,350\\
\# of signers  & 10 & 10 & 1\\
\# of camera angles  & \multicolumn{3}{c}{2}\\
\bottomrule
\end{tabular}
\caption{Statistics of KETI sign language dataset}
\end{table}



\begin{figure}[htb]\label{fig:example_frame}
\centering
\includegraphics[height=1.8in, width=3.2in]{example_8404.jpg}
\caption{Example frame from our sign language dataset. The frame is from the video for the sentence `I am burned'.}
\end{figure}


\section{Our Approach}
We propose a sign recognition system based on the human keypoints that are estimated by pre-existing libraries such as OpenPose~\cite{CaoSWS17,SimonJMS17,WeiRKS16}. Here we develop our system based on OpenPose, an open source toolkit for real-time multi-person keypoint detection. OpenPose can estimate in total 130 keypoints where 18 keypoints are from body pose, 21 keypoints are from each hand, and 70 keypoints from a face. The primary reason of choosing OpenPose as a feature extractor for sign language recognition is that it is robust to many types of variations.

\subsection{Human Keypoint Detection by OpenPose}

First, our recognition system is robust in different cluttered backgrounds as it only detects the human body. Second, the system based on the human keypoint detection works well regardless of signer since the variance of extracted keypoints is negligible. Moreover, we apply the vector standardization technique to further reduce the variance which is dependent on signer. Third, our system can enjoy the benefits of the improvement on the keypoint detection system which has a great potential in the future because of its versatility. For instance, the human keypoint detection system can be used for recognizing different human behaviors and actions given that the relevant dataset is secured. Lastly, the use of high level features is necessary when the scale of the dataset is not large enough. In the case of sign language dataset, it is more difficult to collect than the other dataset as many professional signers should be utilized for recording sign language videos of high quality.

\subsection{Feature Vector Normalization}
There have been many successful attempts to employ various types of normalization methods in order to achieve the stability and speed-up of the training process~\cite{BaKH16,IoffeS15,UlyanovVL16}. One of the main difficulty in sign language translation with the small dataset is the large visual variance as the same sign can look very different depending on the signer. Even if we utilize the feature vector which is obtained by estimating the keypoints of human body, the absolute positions of the keypoints or the scale of the body parts in the frame can be very different.
For this reason, we apply a special normalization method called the {\em object 2D normalization} that suits well in our purpose.

After extracting high-level human keypoints, we normalize the feature vector using the mean and standard deviation of the vector to reduce the variance of the data. Let us denote a 2D feature vector by $V = (v_1, v_2, \ldots, v_n) \in \mathbb{N}^{n\times2}$ that consists of $n$ elements where each element~$v_i \in \mathbb{N}^2,\;1 \le i \le n$ stands for a single keypoint of human part. Each element $v_i = (v_i^x, v_i^y)$ consists of two integers~$v_i^x$ and $v_i^y$ that imply the $x$- and the $y$-coordinates of the keypoint~$v_i$ in the video frame, respectively. From the given feature vector $V$, we can extract the two feature vectors as follows:
\[
\begin{array}{lcl}
V_x & = & (v_1^x, v_2^x, \ldots, v_n^x)\textrm{ and } \\
V_y & = & (v_1^y, v_2^y, \ldots, v_n^y).\\
\end{array}
\]
Simply speaking, we collect the $x$ and $y$-coordinates of keypoints separately while keeping the order. Then, we normalize the $x$-coordinate vector~$V_x$ as follows:
\[
V_x^* = \frac{V_x - \bar{V_x}}{\sigma(V_x)},
\]
where $\bar{V_x}$ is the mean of $V_x$ and $\sigma(V_x)$ is the standard deviation of $V_x$.
Note that $V_y^*$ is calculated analogously.
Finally, it remains to concatenate the two normalized vectors to form the
final feature vector $V^* = [V_x^*; V_y^*] \in \mathbb{N}^{2n}$ which will
be used as the input vector of our neural network.


It should be noted that we assume that the keypoints of lower body parts are not necessary for sign language recognition. Therefore, we only use 124 keypoints from 137 keypoints detected by OpenPose since six keypoints of human pose correspond to lower body parts such as both feet, knees and pelvises as you can see in Figure 2. We randomly sample 10 to 50 keyframes from each sign video. Hence, the dimension of input feature vector is $248 \times |V|$, where $|V| \in \{ 10, 20, 30, 40, 50\}$.

\subsection{Frame Skip Sampling for Data Augmentation}

The main difficulty of training neural networks with small datasets is that
the trained models do not generalize well with data from the validation and
the Test Sets. As the size of dataset is even smaller than the usual cases
in our problem, we utilize the {\em random frame skip sampling} that is commonly used to
process video data such as video classification~\cite{KarpathyTSLSF14} for augmenting
training data. The effectiveness if data augmentation has been proved in
many tasks including image classification~\cite{PerezW17}. Here, we randomly extract multiple representative features of a video.

Given a sign video~$S = (f_1, f_2, \ldots, f_l )$ that contains $l$ frames from $f_1$ to $f_l$, we randomly select a fixed number of frames, say $n$. Then, we first compute the average length of gaps between frames as follows:
\[
z = \left\lfloor\dfrac{l}{n-1}\right\rfloor.
\]

We first extract a sequence of frames with indices from the following sequence $Y =(y, y +Z, y+ 2z \ldots, y + (n-1)z ) \in \mathbb{N}^n$, where $y = \lfloor\frac{l - z(n-1)}{2}\rfloor$ and call it a {\em baseline sequence}. Then, we generate a random integer sequence $R = (r_1,r_2, \ldots, r_n) \in [1,z]^n$ and compute the sum
of the random sequence and the baseline sequence. Note that the value of the last index is clipped to the value in the range of $[1,l]$. We start from the baseline sequence instead of choosing any random sequence of length $l$ to avoid generating random sequences of frames that are possibly not containing `key' moments of signs.


\subsection{Attention-based Encoder-Decoder Network}

The encoder-decoder framework based on RNN architectures such as LSTMs or GRUs is gaining its popularity for neural machine translation~\cite{BahdanauCB14,LuongPM15,SutskeverVL14,VaswaniSPUJGKP17} as it successfully replaces the statistical machine translation methods.

Given an input sentence ${\bf x} = (x_1, x_2, \ldots, x_{T_x})$, an
encoder RNN plays its role as follows:
\[
h_t = {\rm RNN}(x_t, h_{t-1})
\]
where $h_t \in \mathbb{R}^n$ is a hidden state at time $t$. After processing the whole input sentence, the encoder generates a fixed-size context vector that represents the  sequence as follows:
\[
c = q(h_1, h_2, \ldots, h_{T_x}),
\]

For instance, the RNN is an LSTM cell and $q$ simply returns the last hidden state $h_{T_x}$ in one of the original sequence to sequence paper by Sutskever et al.~\cite{SutskeverVL14}.

Now suppose that ${\bf y} = (y_1, y_2, \ldots, y_{T_y})$ is an output sentence that corresponds to the input sentence ${\bf x}$ in training set. Then, the decoder RNN is trained to predict the next word conditioned on all the previously predicted words and the context vector from the encoder RNN. In other words, the decoder computes a probability of the translation {\bf y} by decomposing the joint probability into the ordered conditional probabilities as follows:
\[
p({\bf y}) = \prod_{i=1}^{T_y} p(y_i | \{ y_1, y_2, \ldots, y_{i-1}\}, c).
\]

Now our RNN decoder computes each conditional probability as follows:
\[
p(y_i | y_1, y_2, \ldots, y_{i-1}, c) = {\rm softmax}(g(s_{i})),
\]
where $s_i$ is the hidden state of decoder RNN at time $i$ and $g$ is a linear transformation
that outputs a vocabulary-sized vector.
Note that the hidden state~$s_i$ is computed by
\[
s_i = {\rm RNN}(y_{i-1},s_{i-1}, c),
\]
where $y_{i-1}$ is the previously predicted word, $s_{i-1}$ is the last hidden state of decoder RNN, and $c$ is the context vector computed from encoder RNN.\\

\noindent{\bf Bahdanau attention.} Bahdanau et al.~\cite{BahdanauCB14} conjectured that the fixed-length context vector $c$ is a bottleneck in improving the performance of the translation model and proposed to compute the context vector by automatically searching for relevant parts from the hidden states of encoder. Indeed, this `attention' mechanism has proven really useful in various tasks including but not limited to machine translation. They proposed a new model that defines each conditional probability at time $i$ depending on a dynamically computed context vector $c_i$ as follows:
\[
p(y_i | y_1, y_2, \ldots, y_{i-1}, {\bf x}) = {\rm softmax}(g(s_i)),
\]
where $s_i$ is the hidden state of the decoder RNN at time $i$ which is computed by
\[
s_i = {\rm RNN}(y_{i-1}, s_{i-1}, c_i).
\]
The context vector $c_i$ is computed as a weighted sum of the hidden states from encoder:
\[
c_i = \sum_{j=1}^{T_x} \alpha_{ij} h_j,
\]
where
\[
\alpha_{ij} = \frac{\exp ({\rm score}(s_{i-1}, h_j))}{\sum_{k=1}^{T_x} \exp({\rm score}(s_{i-1}, h_k))}.
\]
Here the function `score' is called an {\em alignment function} that computes how well the two hidden states from the encoder and the decoder, respectively, match. For example, ${\rm score}(s_i, h_j)$, where $s_i$ is the hidden state of the encoder at time $i$ and $h_j$ is the hidden state of the decoder at time $j$ implies the probability of aligning the part of the input sentence around position $i$ and the part of the output sentence around position $j$.
\\

\noindent{\bf Luong attention.} Later, Luong et al.~\cite{LuongPM15} examined a novel attention mechanism which is very similar to the attention mechanism by Bahdananu et al. but different in some details. First, only the hidden states of the top RNN layers in both the encoder and decoder are used instead of using the concatenation of the forward and backward hidden states of the bi-directional encoder and the hidden states of the uni-directional non-stacking decoder. Second, the computation path is simplified by computing the attention matrix after computing the hidden state of the decoder at current time step. They also proposed the following three scoring functions to compute the degree of alignment between the hidden states as follows:
\[
{\rm score}(h_t, h_s) =
\begin{cases}
h_t^\intercal h_s, & \textrm{(Dot)}\\
h_t^\intercal W h_s, & \textrm{(General)} \\
V^\intercal \tanh(W [h_t ;h_s]), & \textrm{(Concat.)}
\end{cases}
\]
where $V$ and $W$ are learned weights. Note that the third one based on the concatenation is originally proposed by Bahdanau et al.~\cite{BahdanauCB14}.
\\

\noindent{\bf Multi-head attention (Transformer).} While the previous encoder-decoder architectures are based on RNN cells, Vaswani et al.~\cite{VaswaniSPUJGKP17} proposed
a completely new network architecture which is based solely on attention mechanisms
without any recurrence and convolutions. The most important characteristic of the Transformer is the {\em multi-head attention} which is used in three different ways as follows:
\begin{enumerate}
    \item Encoder-decoder attention: each position in the decoder can attend over all positions in the input sequence.
    \item Encoder self-attention: each position in the encoder can attend over all positions in the previous layer of the encoder.
    \item Decoder self-attention: each position in the decoder can attend over all positions in the decoder up to and that position.
\end{enumerate}

Moreover, as the Transformer uses neither recurrence nor convolution, the model requires some information about the order of the sequence. To cope with this problem, the Transformer uses {\em positional encoding} which contains the information about the relative or absolute position of the words in the sequence using sine and cosine functions.



\begin{table*}
\centering
\begin{tabular}{@{ }rcccccccc@{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Attention type    &   ROUGE-L & METEOR  & BLEU  & CIDEr &  ROUGE-L & METEOR  & BLEU & CIDEr\\
\midrule
Vanilla seq2seq~\cite{SutskeverVL14} & 88.21 & 65.80 & 88.14 & 3.904 & 66.29 & 43.36 & 59.57 & 2.537\\
Bahdanau et al.~\cite{BahdanauCB14} & 87.75 & 62.53 & 88.35 & 3.898 & 65.80 & 43.32 & 61.93 & 2.537\\
Luong et al.~\cite{LuongPM15} & \textbf{90.90} & \textbf{68.90} & \textbf{91.06} & \textbf{4.022} & 64.93 & 43.73 & 59.58 & 2.485 \\
Transformer~\cite{VaswaniSPUJGKP17} & 88.29 & 56.59 & 87.75 & 3.796 & \textbf{73.93} & \textbf{44.03} & \textbf{69.48} & \textbf{2.928} \\
\bottomrule
\end{tabular}
\caption{Performance comparison of sign language translation on different types of attention mechanisms.}
\label{tab:attention}
\end{table*}

\section{Experimental Results}

We implemented our networks using PyTorch~\cite{PaszkeGCCYDLDAL17}, which is an open source machine learning library for Python.
The Adam optimizer~\cite{KingmaB14} was used to train the network weights and biases for 50 epochs with an initial learning rate $0.001$. During the training, we changed the learning rate every 20 epochs by the exponential decay scheduler with discount factor~$0.5$. We also used the dropout regularization with a probability of 0.8 and the gradient clipping with a threshold 5. Note that the dropout regularization is necessarily high as the size and the variation of the dataset is small compared to other datasets specialized for deep learning training. For the sequence-to-sequence models including the vanilla seq2seq model and two attention-based models, the dimension of hidden states is 256. For the Transformer model, we use the dimension for input and output ($d_{\rm model}$ in~\cite{VaswaniSPUJGKP17}) of 256. The other hyper-parameters used for the Transformer are the same as in the original model including the scheduled Adam optimizer in their own setting. Moreover, the batch size is 128, the augmentation factor is 100, the number of chosen frames is 50, and the object 2D normalization is used unless otherwise specified.

As our dataset is annotated in Korean which is an agglutinative language, the morphological analysis on the annotated sentences should be performed because the size of dictionary can be arbitrarily large if we split sentences into words simply by white-spaces in such languages. For this reason, we used the Kkma part-of-speech (POS) tagger in the KoNLPy package which is a Python package developed for natural language processing of the Korean language to tokenize the sentences into the POS level~\cite{ParkC14}.

In order to evaluate the performance of our translation model, we basically calculate `accuracy' which means the ratio of correctly translated words and sentences. Besides, we also utilized three types of metrics that are commonly used for measuring the performance of machine translation models such as BLEU~\cite{PapineniRWZ02}, ROUGE-L~\cite{Lin08}, METEOR~\cite{BanerjeeL05}, and CIDEr~\cite{VedantamZP15} scores.
\\

\noindent{\bf Sentence-level vs Gloss-level training.} As in~\cite{CamgozHKNB18}, we conduct an experiment to compare the translation performance depending on the type of annotations. Because each sign corresponds to a unique sequence of glosses while it corresponds to multiple natural language sentences, it is easily predictable that the the gloss-level translation shows better performance. Indeed, we can confirm the anticipation from the summary of results provided in Table~\ref{tab:annotation}.

This also leads us to the future work for translating sequences of glosses into natural language sentences. We expect that the sign language translation can be a more feasible task by separating the task of annotating sign videos with natural language sentences by two sub-tasks where we annotate sign videos with glosses and annotate each sequence of glosses with natural language sentences.\\

\begin{table*}[htb]
\centering
\begin{tabular}{@{ } rcccccccc @{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Annotation   &  Accuracy & ROUGE-L & METEOR  & BLEU  & Accuracy & ROUGE-L & METEOR  & BLEU \\
\midrule
Sentence-level & 80.93 & 92.93 & 65.11 & 88.08 & 44.76 & 64.89 & 39.89 & 55.61 \\
Gloss-level  & \textbf{94.59} & \textbf{96.95} & \textbf{72.60} & \textbf{95.03} &\textbf{60.57} & \textbf{68.34} & \textbf{41.32} & \textbf{57.94} \\
\bottomrule
\end{tabular}
\caption{Comparison of sign language translation performance on different types of annotations.}
\label{tab:annotation}
\end{table*}

\noindent{\bf Effect of feature normalization methods.}
In order to evaluate the effect of the feature normalization method on the keypoints estimated by OpenPose, we compare the following five cases: 1) no normalization, 2) feature normalization, 3) object normalization, 4) 2-dimensional (2D) normalization, and 5) object 2D normalization. In the first case, we do not perform any normalization step on the keypoint feature generated by concatenating the coordinate values of all keypoints. In the feature normalization, we create a keypoint feature as in 1) and normalize the feature with the mean and standard deviation of the whole feature. In the object normalization, we normalize the keypoint features obtained from two hands, body, and face, respectively, and concatenate them to generate a feature that represents the frame. We also consider the case of 2D normalization in which we normalize the $x$- and $y$-coordinates separately.
Lastly, the object 2D normalization is the normalization method that we propose in the paper.

\begin{table}
\centering{\small
\begin{tabular}{@{  }p{2.15cm}cccc@{  }}
\toprule
Method & ROUGE-L & METEOR & BLEU & CIDEr \\ \midrule
Feature Norm. & 63.56 & 41.02 & 55.39 & 2.263\\
2D Norm. & 64.22 & 41.62 & 56.79 & 2.380\\
Object Norm. & 64.41 & 41.14 & 55.82 & 2.415\\
Object 2D Norm. & \textbf{64.93} & \textbf{43.73} & \textbf{59.58} & \textbf{2.485} \\
\bottomrule
\end{tabular}
}
\caption{Effect of different feature normalization methods on the translation performance. The results are obtained on the test set.}
\label{tab:normalization}
\end{table}

Table~\ref{tab:normalization} summarizes the result of our experiments.
The table does not contain the results of the case without any normalization as it turns out that the proposed object 2D normalization method is superior to the other normalization methods we considered. Especially, when we train our neural network with the keypoint feature vector which is obtained by simply concatenating the $x$ and $y$ coordinates of keypoints without any normalization, the validation loss never decreases. While any kind of normalization seems working positively, it is quite interesting to see that there is an additional boost in translation performance when the object-wise normalization and the 2D normalization are used together.
\\

\begin{table*}
\centering
\begin{tabular}{@{ }rcccccccc@{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Augmentation factor    &   ROUGE-L & METEOR  & BLEU  & CIDEr &  ROUGE-L & METEOR  & BLEU & CIDEr\\
\midrule
100 & \textbf{90.90} & 68.90 & \textbf{91.06} & 4.022 & 64.93 & 43.73 & 59.58 & 2.485\\
50 & 90.31 & \textbf{69.01} & 91.04 & \textbf{4.052} & \textbf{67.16} & \textbf{45.37} & \textbf{63.12} & \textbf{2.680}\\
10 & 89.01 & 65.19 & 89.25 & 3.935 & 62.62 & 40.81 & 57.05 & 2.365\\
\bottomrule
\end{tabular}
\caption{Effects of data augmentation by random frame sampling on sign language translation performance.}
\label{tab:augmentation}
\end{table*}



\begin{table*}
\centering
\begin{tabular}{@{ }rcccccccc@{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Number of frames    &   ROUGE-L & METEOR  & BLEU  & CIDEr &  ROUGE-L & METEOR  & BLEU & CIDEr\\
\midrule
50 & 90.90 & 68.90 & 91.06 & 4.022 & 64.93 & 43.73 & 59.58 & 2.485\\
40 & 90.66 & 68.98 & 91.33 & \textbf{4.094} & \textbf{67.51} & 44.78 & \textbf{62.50} & 2.633\\
30 & \textbf{91.19} & \textbf{69.30} & \textbf{91.44} & 4.083 & 65.98 & 43.37 & 59.23 & 2.528\\
20 & 89.07 & 65.76 & 89.46 & 3.995 & 67.20 & \textbf{45.08} & 62.29 & \textbf{2.651}\\
10 & 75.99 & 51.58 & 72.98 & 3.104 & 61.69 & 40.28 & 55.02 & 2.322\\
\bottomrule
\end{tabular}
\caption{Effects of the number of sampled frames on sign language translation performance.}
\label{tab:numframes}
\end{table*}


\begin{table*}[h!]
\centering
\begin{tabular}{@{ }rcccccccc@{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Batch size    &   ROUGE-L & METEOR  & BLEU  & CIDEr &  ROUGE-L & METEOR  & BLEU & CIDEr\\
\midrule
128 & \textbf{90.90} & \textbf{68.90} & 91.06 & \textbf{4.022} & \textbf{64.93} & \textbf{43.73} & \textbf{59.58} & \textbf{2.485}\\
64 & 90.16 & 68.19 & \textbf{91.08} & 3.956 & 63.45 & 41.62 & 57.34 & 2.398\\
32 & 86.73 & 64.79 & 87.49 & 3.748 & 64.34 & 42.34 & 57.72 & 2.394\\
16 & 86.84 & 62.54 & 86.56 & 3.733 & 63.68 & 41.38 & 57.07 & 2.355\\
\bottomrule
\end{tabular}
\caption{Effects of the batch size on sign language translation performance.}
\label{tab:batch_size}
\end{table*}

\noindent{\bf Effect of augmentation factor.}
We examine the effect of data augmentation by random frame skip sampling and summarize the experimental results in Table~\ref{tab:augmentation}. We call the number of training samples randomly sampled from a single sign video the {\em augmentation factor}.

It should be noted that we do not include the result when we do not augment data by random frame sampling because the validation loss does not decrease at all due to overfitting. The result shows that the optimal augmentation factor is indeed 50. Considering the fact that the average number of frames in a sign video is larger than 200, the average length of gaps between frames is larger than 4. Then, there are $4^{50}$ possible random sequences on average and consequently the probability of having exactly same training sample is really low. However, the result implies that increasing the augmentation factor has a limit at some point.\\

\noindent{\bf Effect of attention mechanisms.}
Here we compare four types of encoder-decoder architectures that are specialized in various machine translation tasks. Table~\ref{tab:attention} demonstrates the clear contrast between the attention-based model by Luong et al.~\cite{LuongPM15} and the Transformer~\cite{VaswaniSPUJGKP17}. While the model of Luong et al. shows better performance than the Transformer on the validation set that contains more similar data to the training set, the Transformer generalizes much better to the test set which consists of sign videos of an independent signer.
\\

\noindent{\bf Effect of the number of sampled frames.}
It is useful to know the optimal number of frames if we plan to develop a real-time sign language translation system because we can reduce the computational cost of the inference engine by efficiently skipping unnecessary frames.
Table~\ref{tab:numframes} shows how the number of sampled frames affects the translation performance. As the sequence-to-sequence model works for any variable-length input sequences, we do not necessarily fix the number of sampled frames. However, it is useful to know the optimal number of frames as the translation performance of the sequence-to-sequence models tends to decline due to the vanishing gradient problem~\cite{PascanuMB13}.

Interestingly, our experimental result shows that the optimal number of frames for the best translation performance is 30 for the validation set and 50 for the test set.
\\

\noindent{\bf Effect of batch size.}
Recently, it is increasingly accepted that training with small batch often generalizes better to the test set than training with large batch~\cite{HofferHS17,SmithKL17}. However, our experimental results provided in
Table~\ref{tab:batch_size} shows the opposite phenomenon. We suspect that this is due to the scale of the original dataset because large batch is known to be useful to prevent
overfitting to some extent.

\subsection{Ablation study}

We also study the effect of the use of keypoint information from two hands, body, and face. The experimental results summarized in Table~\ref{tab:ablation} imply that the keypoint information from both hands is the most important among all the keypoint information from hands, face, and body.

\begin{table}[H]
\centering{\small
\begin{tabular}{@{  }p{2.2cm}cccc@{  }}
\toprule
Method & ROUGE-L & METEOR & BLEU & CIDEr \\ \midrule
Body & 57.14 & 36.41 & 49.29 & 2.080\\
Hand & 65.49 & 42.94 & 58.99 & 2.433\\
Body, Face & 48.10 & 30.20 & 38.56 & 1.528\\
Hand, Face & 62.85 & 40.48 & 55.03 & 2.350\\
Hand, Body & \textbf{68.13} & \textbf{44.37} & \textbf{60.61} & \textbf{2.621}\\
Hand, Body, Face & 64.93 & 43.73 & 59.58 & 2.485\\
\bottomrule
\end{tabular}
}
\caption{Ablation study on the contributions of keypoints from body, face, and hands. The results are obtained on the test set.}
\label{tab:ablation}
\end{table}

Interestingly, the experimental result tells us that the keypoint information from face does not help to improve the performance in general. The performance even drops when we add face keypoints in all cases. We suspect that the reason is partly due to the imbalanced number of keypoints from different parts. Recall that the number of keypoints from face is 70 and this is much larger than the number of the other keypoints.

While the keypoints from both hands are definitely the most important features to understand signs, it is worth noting that the 12 keypoints from body are boosting up the performance. Actually, we lose the information about relative positions of parts from each other as we normalize the coordinates of each part separately. For instance, there is no way to infer the relative positions of two hands with the normalize feature vectors from both hands. However, it is possible to know the relative position from the keypoints of body as there also exist keypoints corresponding to the hands.

\section{Conclusions}
In this work, we have introduced a new sign language dataset which is manually annotated in Korean spoken language sentences and proposed a neural sign language translation model based on the sequence-to-sequence translation models. It is well-known that the lack of large sign language dataset significantly hinders the full utilization of neural network based algorithms for the task of sign language translation that are already proven very useful in many tasks. Moreover, it is really challenging to collect a sufficient amount of sign language data as we need helps from sign language experts.

For this reason, we claim that it is inevitable to extract high-level features from sign language video with a sufficiently lower dimension. We are able to successfully train a novel sign language translation system based on the human keypoints that are estimated by a famous open source project called OpenPose developed by Hidalgo et al.

In the future, we aim at improving our sign language translation system by exploiting various data augmentation techniques using the spatial properties of videos. It is also important to expand the KETI sign language dataset to sufficiently larger scale by recording videos of more signers in different environments.

\clearpage{\small
\bibliographystyle{ieee}
\bibliography{egbib}
}

\newpage

\onecolumn
\section{Supplemental Material}



\noindent{\bf Keypoint information used in sign language translation.} We use the estimated coordinates of 124 keypoints of a signer to understand the sign language of the signer, where 12 keypoints are from human body, 21 keypoints are from each hand, and 70 keypoints are from face. See Figure~\ref{fig:keypoints} for example.\footnote{https://github.com/CMU-Perceptual-Computing-Lab/openpose/blob/master/doc/output.md} Note that the number of keypoints from human body is 25 but we select 12 keypoints that correspond to upper body parts. The chosen indices and the names of the parts are as follows:
\begin{itemize}
    \item 0 (nose),
    \item 1 (neck),
    \item 2 (right shoulder),
    \item 3 (right elbow),
    \item 4 (right wrist),
    \item 5 (left shoulder),
    \item 6 (left elbow),
    \item 7 (left wrist),
    \item 15 (right eye),
    \item 16 (left eye),
    \item 17 (right ear), and
    \item 18 (left ear).
\end{itemize}

In future, we plan to plug in an additional attention module to learn which keypoint contributes more to understand the sign video
\\

\begin{figure*}[ht]
\centering
\includegraphics[height=3in, width=2in]{keypoints_pose_25.png}
\includegraphics[height=3in, width=2in]{keypoints_hand}
\includegraphics[height=3in, width=2in]{keypoints_face}
\caption{The human keypoints used for sign language recognition. Note that the figures are borrowed from the public web page of the OpenPose project~\cite{CaoSWS17,SimonJMS17,WeiRKS16}.}
\label{fig:keypoints}
\end{figure*}



\noindent{\bf Comparison with CNN-based approaches.}
In Table~\ref{tab:CNN}, we compare our approach to the classical methods
based on CNN features extracted from well-known architectures such as
ResNet~\cite{HeZRS16} and VGGNet~\cite{SimonyanZ14a}.

Since the size of sign video frames ($1,920 \times 1,080$) is different to the size of input of CNN models (224 $\times$ 224), we first crop the central area of frames in $1,080 \times 1,080$ and resize the frames to $224 \times 224$.

The experimental results show that ResNet-101 exhibits the best translation performance on the validation set and the VGGNet-19 demonstrates the best performance on the test set. In general, the performance difference on the validation set is not large but it is apparent that the VGGNet models are much better in generalizing to the test set compared to the ResNet models.

Expectably, the translation models using the CNN extracted features show significantly worse translation performance than the models using the human keypoint features. It is still interesting to know whether the combination of any CNN-based features and human keypoint features works better than when we solely rely on the human keypoint features. As the size of sign language dataset grows, we expect that the CNN-based models improve their performances and generalize much better.
\\

\begin{table*}[ht]
\centering
\begin{tabular}{@{ }rcccccccc@{ }}
\toprule
& \multicolumn{4}{c}{Validation Set} & \multicolumn{4}{c}{Test Set} \\
\cmidrule(lr){2-5} \cmidrule(lr){6-9}
Feature type    &   ROUGE-L & METEOR  & BLEU  & CIDEr &  ROUGE-L & METEOR  & BLEU & CIDEr\\
\midrule
VGGNet-16~\cite{SimonyanZ14a}  &  69.84 & 44.15 & 60.39 & 2.611 & 45.63 & 26.58 & 29.86 & 1.170\\
VGGNet-19~\cite{SimonyanZ14a}  &  68.38 & 42.87 & 57.71 & 2.425 & {\bf 49.16} & {\bf 28.91} & {\bf 32.51} & {\bf 1.225}\\
ResNet-50~\cite{HeZRS16}  & 65.30 & 40.62 & 56.70 & 2.305 & 36.35 & 21.22 & 17.92 & 0.642\\
ResNet-101~\cite{HeZRS16} & {\bf 70.66} & {\bf 44.61} & {\bf 61.88} & {\bf 2.627} & 40.91 & 22.76 & 23.88 & 0.807\\
ResNet-152~\cite{HeZRS16} & 64.54 & 40.09 & 54.32 & 2.241 & 37.52 & 20.91 & 18.08 & 0.592\\
\midrule
OpenPose~\cite{CaoSWS17,SimonJMS17,WeiRKS16} & 90.31 & 69.01 & 91.04 & 4.052 & 67.16 & 45.37 & 63.12 & 2.680\\
\bottomrule
\end{tabular}
\caption{Performance comparison with translation models based on CNN-based feature extraction techniques. Note that the augmentation factor in this experiment is all set to 50.}
\label{tab:CNN}
\end{table*}

\noindent{\bf Attention maps.} In Figure~\ref{fig:attention}, we depict attention maps of the sentence-level translation model on several successful and unsuccessful cases. We can see that the attention weights are more well-distributed on the important frames of the video in the successful case when generating the natural language sentence compared to the failure case.  However, the order of the attentions is quite irregular in Figure~\ref{fig:attention} as there is no direct mapping between sign video frames and tokens of the output sentence.

We also describe the attention maps of the gloss-level translation model in Figure~\ref{fig:attention_gloss}. In the attention map of the successful case, we can see that the order of the attentions are more regular than the successful one on the sentence-level. This is because there is a more clear mapping between the continuous frames in the video and the sign gloss on the gloss-level translation.\\


\begin{figure}[ht]
\centering
\includegraphics[height=2.5in, width=3.2in]{attention_map.png}
\includegraphics[height=2.5in, width=3.2in]{attention_map_fail.png}
\caption{Attention maps of the sentence-level translation model. The first one is a map of a successful case and the second one is a failure case.}
\label{fig:attention}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[height=2.5in, width=3.2in]{attention_map_gloss.png}
\includegraphics[height=2.5in, width=3.2in]{attention_map_gloss_fail.png}
\caption{Attention maps of the gloss-level translation model. The first one is a map of a successful case and the second one is a failure case.}
\label{fig:attention_gloss}
\end{figure}


\noindent{\bf Sign language annotation.} We annotate each sign video with five different natural language sentences in Korean.
Table~\ref{tab:annotation} contains ten examples from 105 examples in total.

Moreover, we annotate a sign video with a unique sign gloss as presented in~Table~\ref{tab:annotation}.

\begin{table*}[ht]
\centering{\small
\begin{tabular}{@{  }cllll@{  }}
\toprule
ID  & Sentence 1 (in Korean) & Sentence 2 (in Korean) & English sentence & Sign gloss \\ \midrule
\bottomrule
\end{tabular}
}
\caption{Ten examples of our sign language annotations. We annotate each sign with five natural language sentences in Korean and a unique sign gloss. We only provide two sentences in the table due to space limitations.}
\label{tab:annotation}
\end{table*}


\end{document}


